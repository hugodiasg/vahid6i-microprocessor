/* Generated by Yosys 0.27+22 (git sha1 53c0a6b78, gcc 12.2.0-3ubuntu1 -fPIC -Os) */

module alu(a, b, s0, s1, rp_zero, ans);
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  wire _06_;
  wire [15:0] _07_;
  wire _08_;
  wire _09_;
  wire [15:0] _10_;
  wire [15:0] _11_;
  wire [15:0] _12_;
  wire [15:0] _13_;
  input [15:0] a;
  wire [15:0] a;
  output [15:0] ans;
  wire [15:0] ans;
  input [15:0] b;
  wire [15:0] b;
  output rp_zero;
  wire rp_zero;
  input s0;
  wire s0;
  input s1;
  wire s1;
  assign _00_ = a == 16'h0000;
  assign _01_ = _00_ ? 1'h1 : 1'h0;
  assign _02_ = ~ s1;
  assign _03_ = ~ s0;
  assign _04_ = _02_ & _03_;
  assign _05_ = ~ s1;
  assign _06_ = _05_ & s0;
  assign _07_ = a + b;
  assign _08_ = ~ s0;
  assign _09_ = s1 & _08_;
  assign _10_ = a - b;
  assign _11_ = _09_ ? _10_ : 16'hzzzz;
  assign _12_ = _06_ ? _07_ : _11_;
  assign _13_ = _04_ ? a : _12_;
  assign rp_zero = _01_;
  assign ans = _13_;
endmodule

module muxf(s1, s0, ans, d_r_data, rf_w_data, w_data);
  wire _0_;
  wire _1_;
  wire _2_;
  wire [15:0] _3_;
  input [15:0] ans;
  wire [15:0] ans;
  input [15:0] d_r_data;
  wire [15:0] d_r_data;
  input [7:0] rf_w_data;
  wire [7:0] rf_w_data;
  input s0;
  wire s0;
  input s1;
  wire s1;
  wire [1:0] s1_s0;
  output [15:0] w_data;
  wire [15:0] w_data;
  assign _0_ = s1_s0 == 2'h0;
  assign _1_ = s1_s0 == 2'h1;
  assign _2_ = s1_s0 == 2'h2;
  function [15:0] \31 ;
    input [15:0] a;
    input [47:0] b;
    input [2:0] s;
    (* parallel_case *)
    casez (s)
      3'b??1:
        \31  = b[15:0];
      3'b?1?:
        \31  = b[31:16];
      3'b1??:
        \31  = b[47:32];
      default:
        \31  = a;
    endcase
  endfunction
  assign _3_ = \31 (16'hzzzz, { 8'h00, rf_w_data, d_r_data, ans }, { _2_, _1_, _0_ });
  assign s1_s0 = { s1, s0 };
  assign w_data = _3_;
endmodule

module po(RF_s0, RF_s1, RF_W_data, D_R_data, RF_W_wr, RF_Rp_rd, RF_Rq_rd, clock, RF_W_addr, RF_Rp_addr, RF_Rq_addr, alu_s0, alu_s1, RF_Rp_zero, D_W_data);
  wire [15:0] _0_;
  wire [15:0] _1_;
  wire [15:0] _2_;
  wire _3_;
  wire [15:0] _4_;
  input [15:0] D_R_data;
  wire [15:0] D_R_data;
  output [15:0] D_W_data;
  wire [15:0] D_W_data;
  input [3:0] RF_Rp_addr;
  wire [3:0] RF_Rp_addr;
  input RF_Rp_rd;
  wire RF_Rp_rd;
  output RF_Rp_zero;
  wire RF_Rp_zero;
  input [3:0] RF_Rq_addr;
  wire [3:0] RF_Rq_addr;
  input RF_Rq_rd;
  wire RF_Rq_rd;
  input [3:0] RF_W_addr;
  wire [3:0] RF_W_addr;
  input [7:0] RF_W_data;
  wire [7:0] RF_W_data;
  input RF_W_wr;
  wire RF_W_wr;
  input RF_s0;
  wire RF_s0;
  input RF_s1;
  wire RF_s1;
  wire \alu_0:11 ;
  wire [15:0] \alu_0:12 ;
  input alu_s0;
  wire alu_s0;
  input alu_s1;
  wire alu_s1;
  wire [15:0] ans;
  input clock;
  wire clock;
  wire [15:0] \muxf_0:2 ;
  wire [15:0] \regf_0:5 ;
  wire [15:0] \regf_0:6 ;
  wire [15:0] rp_data;
  wire [15:0] rq_data;
  wire [15:0] w_data;
  alu alu_0 (
    .a(rp_data),
    .ans(_4_),
    .b(rq_data),
    .rp_zero(_3_),
    .s0(alu_s0),
    .s1(alu_s1)
  );
  muxf muxf_0 (
    .ans(ans),
    .d_r_data(D_R_data),
    .rf_w_data(RF_W_data),
    .s0(RF_s0),
    .s1(RF_s1),
    .w_data(_0_)
  );
  regf regf_0 (
    .clock(clock),
    .rp_addr(RF_Rp_addr),
    .rp_data(_2_),
    .rp_rd(RF_Rp_rd),
    .rq_addr(RF_Rq_addr),
    .rq_data(_1_),
    .rq_rd(RF_Rq_rd),
    .w_addr(RF_W_addr),
    .w_data(w_data),
    .w_wr(RF_W_wr)
  );
  assign ans = \alu_0:12 ;
  assign rp_data = \regf_0:6 ;
  assign rq_data = \regf_0:5 ;
  assign w_data = \muxf_0:2 ;
  assign \muxf_0:2  = _0_;
  assign \regf_0:5  = _1_;
  assign \regf_0:6  = _2_;
  assign \alu_0:11  = _3_;
  assign \alu_0:12  = _4_;
  assign RF_Rp_zero = \alu_0:11 ;
  assign D_W_data = rp_data;
endmodule

module regf(w_addr, rp_addr, rq_addr, w_wr, rp_rd, rq_rd, clock, w_data, rq_data, rp_data);
  reg [15:0] _0_;
  reg [15:0] _1_;
  wire [335:0] _2_;
  wire [15:0] _3_;
  wire [335:0] _4_;
  wire [15:0] _5_;
  input clock;
  wire clock;
  input [3:0] rp_addr;
  wire [3:0] rp_addr;
  output [15:0] rp_data;
  wire [15:0] rp_data;
  input rp_rd;
  wire rp_rd;
  input [3:0] rq_addr;
  wire [3:0] rq_addr;
  output [15:0] rq_data;
  wire [15:0] rq_data;
  input rq_rd;
  wire rq_rd;
  input [3:0] w_addr;
  wire [3:0] w_addr;
  input [15:0] w_data;
  wire [15:0] w_data;
  input w_wr;
  wire w_wr;
  reg [15:0] rf [20:0];
  always @(posedge clock) begin
    if (w_wr)
      rf[{ 1'h0, w_addr }] <= w_data;
  end
  assign _5_ = rf[{ 1'h0, rq_addr }];
  assign _3_ = rf[{ 1'h0, rp_addr }];
  always @*
    if (rq_rd) _0_ = _5_;
  always @*
    if (rp_rd) _1_ = _3_;
  assign rq_data = _0_;
  assign rp_data = _1_;
endmodule
